---
title: 防抖和节流
date: 2020-04-24 00:29:42
tags: ["防抖","节流"]
top_img: /img/防抖和节流/1.PNG
cover: /img/防抖和节流/1.PNG
categories: 练习笔记
copyright: false
---

## 简介
函数防抖（debounce）与函数节流（throttle）都是为了限制函数的执行频次，以优化函数触发频率过高导致的响应速度跟不上触发频率，出现延迟，假死或卡顿的现象。
![](/img/防抖和节流/1.PNG)

## 防抖
防抖指触发事件后在n秒内函数只执行一次，若在n秒内再次触发则重新计算（例如：点击按钮，需要在两秒后调用函数，如果1.5秒时又点了按钮，前面过去的1.5秒就失效了，需要重新等待2秒后调用函数）

## 节流
节流指触发事件后在n秒内函数只执行一次，不管在n秒内触发几次，只有第一次触发事件执行的函数（例如：点击按钮后，需要在两秒后调用函数，如果两秒内又点击了按钮，则触发事件失效，只有过了两秒后再点击按钮才能触发事件调用函数）

## 代码演示
```
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <h1 style="text-align: center;">防抖和节流练习</h1>
    <input id="search" type="text" oninput="count()">
    <div id="content" style="height: 150px; line-height: 150px; text-align: center; font-size: 30px; background: #ccc;
    margin-top: 20px;"></div>
    <script>
        //没有添加防抖或节流处理，鼠标在content移动就触发了count事件，或者在search输入内容就触发count事件(oninput事件是在输入框中输入时就会触发)
        let num = 1;
        let content = document.getElementById("content");
        function count() {
            content.innerHTML = num++;
        }
        //content.onmousemove = count;

        //防抖 debounce
        //让鼠标移动完毕后过两秒再执行（延迟执行：先等待再执行）
        // function debounce(func,wait){
        //     let timeout;
        //     return function(){
        //         if(timeout) clearTimeout(timeout);
        //         timeout = setTimeout(function(){
        //             func.apply(this); //执行func函数
        //         },wait)
        //     }
        // }

        //让鼠标移动完毕立即执行，过两秒后才能下一次执行（立即执行：先执行再等待）
        function debounce(func, wait) {
            let timeout;
            return function () {
                if (timeout) clearTimeout(timeout); //取消之前的任务
                let callNow = !timeout; //类型转换
                timeout = setTimeout(() => { //增加一个定时器
                    timeout = null;
                }, wait)
                if (callNow) func.apply(this); //第一次执行
            }
        }
        //content.onmousemove = debounce(count,2000);


        //节流 throttle
        //让鼠标移动完毕执行后过两秒才能执行

        //定时器 固定的时间去发送请求
        // function throttle(func, wait) {
        //     let timeout; //定义一个定时器句柄
        //     return function () {
        //         if (!timeout) { //是否存在定时器
        //             timeout = setTimeout(() => { //创建一个定时器
        //                 timeout = null;
        //                 func.apply(this); //func == count apply调用count
        //             },wait)
        //         }
        //     }
        // }
        
        //时间戳
        function throttle(func, wait) {
            let prev = 0; //上次记录的时间
            return function(){
                let now = Date.now(); //当前时间
                if(now - prev > wait){ //判断是否经过等待时间
                    func.apply(this) //执行函数 
                    prev = now;  //重置上次记录时间
                }
            }
        }

        content.onmousemove = throttle(count, 2000);

    </script>
</body>

</html>
```

